!to "t2048", cbm
*=$c000

!zone main
GETIN   = $FFE4
CHAROUT = $FFD2
; A7-AB are used by the cassete routines => not needed
PLAYFIELD_PTR = $A7

!macro use .addr {
    lda #<.addr
    sta PLAYFIELD_PTR
    lda #>.addr
    sta PLAYFIELD_PTR+1
}

!macro println .func {
    lda #13                
    jsr .func           ; print CR
    lda #10
    jsr .func           ; print LF
}

.main
    jsr clearPlayingField
    ; clear result counter
    lda #00
    sta POINTS
    sta POINTS+1
    sta POINTS+2
    
    +use PLAYINGFIELD
    jsr renderPlayingField
    +println CHAROUT

    jsr savePlayingField

    jsr testPlayingFieldChanged
    clc
    adc #$30
    jsr CHAROUT

    ldx #2
    lda #1
    jsr calcPlayFieldOffset
    lda HEX_CHARS, Y
    jsr CHAROUT
    +println CHAROUT

    rts

HEX_CHARS
!tx "0123456789ABCDEF"
DEC_CHARS
!tx "0123456789"
POWERS 
!byte $00, $02
!byte $00, $04
!byte $00, $08
!byte $00, $16
!byte $00, $32
!byte $00, $64
!byte $01, $28
!byte $02, $56
!byte $05, $12
!byte $10, $24
!byte $20, $48

; --------------------------------------------------
; Wait for a key and return ASCII Code of key in Accumulator
; 
; INPUT:  None
; OUTPUT: ASCII code of read character in accumulator
; --------------------------------------------------
waitForKey
    jsr GETIN         ; get key from keyboard
    cmp #0            ; if 0, no key pressed
    beq waitForKey    ; loop if no key pressed

    rts               ; ASCII Code of pressed key is now in accumulator


POINTS 
!byte $00, $00, $00
PLAYINGFIELD
!byte $00, $00, $00, $00
!byte $00, $00, $00, $00
!byte $00, $00, $00, $00
!byte $00, $00, $00, $00
OLDPLAYINGFIELD
!byte $00, $00, $00, $00
!byte $00, $00, $00, $00
!byte $00, $00, $00, $00
!byte $00, $00, $00, $00
; --------------------------------------------------
; Draws playing field 
; 
; INPUT:  Address of playing field in $A7/$A8
; OUTPUT: None
; --------------------------------------------------
renderMainField
    +use PLAYINGFIELD
renderPlayingField 
    jsr renderPoints
    ldx #0                ; column counter             
    ldy #0                ; byte counter
.charLoop    
    clc                   
    lda (PLAYFIELD_PTR), y
    adc #65
    jsr CHAROUT           ; print char
    inx 
    cpx #04
    bne .nextChar         ; start a new column?
    ldx #0                ; yes
    +println CHAROUT
.nextChar                 ; print next character
    iny                   ; increment byte counter
    cpy #16
    bne .charLoop

    rts               


; --------------------------------------------------
; renderPoints represents the current result points on the screen
; 
; INPUT:  None
; OUTPUT: None
; --------------------------------------------------
renderPoints
    ldy #00
.outLoop
    ; print current points
    lda POINTS, y
    and #$F0                ; mask out most significant digit
    lsr                     ; shift right 4 times
    lsr
    lsr
    lsr 
    tax
    lda DEC_CHARS, X       ; use result to determine decimal digit
    jsr CHAROUT
    lda POINTS, y
    and #$0F               ; mask out least significant digit
    tax
    lda DEC_CHARS, X
    jsr CHAROUT
    iny 
    cpy #03                ; all digits printed?
    bne .outLoop

    +println CHAROUT
    rts


!macro copyField .source, .target {
    ldy #0                ; byte counter
.charLoop2    
    lda .source,Y         ; copy one byte
    sta .target,y
    iny                   ; increment byte counter
    cpy #16               ; end pos reached?
    bne .charLoop2        ; no, copy nect byte
    rts               
}


; --------------------------------------------------
; savePlayingField copies the PLAYINGFIELD to OLDPLAYINGFIELD.
; 
; INPUT:  None
; OUTPUT: None
; --------------------------------------------------
savePlayingField 
    +copyField PLAYINGFIELD, OLDPLAYINGFIELD           


; --------------------------------------------------
; restorePlayingField copies the  OLDPLAYINGFIELD to PLAYINGFIELD.
; 
; INPUT:  None
; OUTPUT: None
; --------------------------------------------------
restorePlayingField 
    +copyField OLDPLAYINGFIELD, PLAYINGFIELD           


; --------------------------------------------------
; testPlayingFieldChanged compares PLAYINGFIELD to OLDPLAYINGFIELD.
; 
; INPUT:  None
; OUTPUT: 0 in accu if no change was detected. 1 otherwise
; --------------------------------------------------
testPlayingFieldChanged 
    ldy #0                ; byte counter
.charLoop3    
    lda PLAYINGFIELD,Y
    cmp OLDPLAYINGFIELD,y ; compare old with current
    bne .changeDetected   ; current pos differs => return
    iny                   ; increment byte counter
    cpy #16               ; end pos reached?
    bne .charLoop3        ; no, test next pos
    lda #0                ; playing fields does not differ
    rts
.changeDetected           ; playing fields differ
    lda #1
    rts               


;--------------------------------------------------
; clearPlayingField sets all values in the playing field to 0.
; 
; INPUT:  None
; OUTPUT: None
; --------------------------------------------------
clearPlayingField 
    ldy #0                ; byte counter
    lda #0
.charLoop4    
    sta PLAYINGFIELD,y    ; store 0 in playing field
    iny                   ; increment byte counter
    cpy #16
    bne .charLoop4

    rts


;--------------------------------------------------
; calcPlayFieldOffset calculates the offset of the position x,y 
; 
; INPUT:  x-pos (0-3) in register X, y-pos (0-3) in accu
;         X and A are not changed by this call
; OUTPUT: offset in register Y
; --------------------------------------------------
calcPlayFieldOffset
    pha            ; save accu
    asl            ; * 2
    asl            ; * 2
    stx SCRATCH    ; x-pos in temp memory
    clc
    adc SCRATCH    ; add x-pos to row base address
    tay            ; move result to y
    pla            ; restore accu
     
    rts
SCRATCH !byte $00

;--------------------------------------------------
; addPoints adds a new value to the current result  
; 
; INPUT:  Value to add to current points as log_2 value 1-11 in accu
; OUTPUT: None
; --------------------------------------------------
addPoints
    ; transform 1-11 to 0-10
    ; in essence decrement contents of accumulator
    tay
    dey
    tya     
    ; calc offset of 2**(contents of accu)            
    asl                    ; *2
    tax 
    inx                    ; x now contains 2*accu + 1
    sed
    clc
    ; add least significant digits
    lda POINTS+2
    adc POWERS,X
    sta POINTS+2
    dex                    ; x now contains offset of most significant digits
    ; add "medium" significant digits
    lda POINTS+1 
    adc POWERS,X
    sta POINTS+1
    ; add carry to most significant digits
    lda POINTS
    adc #00
    cld 
    rts


BUFFERIN   !byte $00, $00, $00, $00
BUFFERTEMP !byte $00, $00, $00, $00
TEMPLEN !byte $00

!macro compressBuffer .source, .target {
    ; Clear target buffer
    ; This macro copies all nonzero bytes from .soure to .target 
    ; at the end x contains the number of bytes copied
    lda #0             
    sta .target
    sta .target+1
    sta .target+2
    sta .target+3    
    ; remove all zero elements and write result to target
    ldy #0             ; read index
    ldx #0             ; write index
.loop4                 
    lda .source, Y     ; load input data
    cmp #0             ; Is it zero?
    beq .next          ; yes, write nothing
    sta .target, X     ; write nonzero value in target buffer
    inx                ; increment write offset
.next
    iny                ; increment read offset
    cpy #4             ; end reached?
    bne .loop4         ; no?
}


;--------------------------------------------------
; shiftRowLeft implements a left shift of a row. All other shifts of rows and 
; columns can be mapped to this. Input and output in BUFFERIN 
; 
; INPUT:  None
; OUTPUT: None
; --------------------------------------------------
shiftRowLeft
    +compressBuffer BUFFERIN, BUFFERTEMP 

    ; X holds number of bytes copied
    cpx #0
    beq .done            ; no bytes were transferred => Input data was all zero. Nothing else to do
    cpx #1               
    beq .doCopy          ; Only one byte was copied, no merging necessary, only copy data back to BUFFERIN

    ; Here BUFFERTEMP contains at least two nonzero elements
    ; perform merging of equal elements
    ; we have a sliding window of length two, that is moved over the conpressed buffer from left to right
    dex                  
    stx TEMPLEN          ; now x contains the last nonzero position in BUFFERTEMP
    ldx #0               ; Begin of sliding window at pos 0
    ldy #1               ; End of sliding window at pos 1
.mergeLoop
    lda BUFFERTEMP, X    ; load frist and second element of window
    cmp BUFFERTEMP, Y
    bne .skip            ; Elements not equal. Move window one position
    lda #0               ; Elements in window are equal, merge them
    sta BUFFERTEMP, y    ; clear second element of window
    inc BUFFERTEMP, X    ; increment first window element

    ; save registers
    txa
    pha
    tya
    pha

    ; add points
    lda BUFFERTEMP, X
    jsr addPoints

    ; restore registers
    pla
    tay
    pla
    tax

    inx                  ; move window two elements
    inx
    iny
    iny
    cpx TEMPLEN
    bcc .mergeLoop       ; start of window < last pos with nonzero element
    bcs .doCopy          ; start of window >= last pos with zero element
.skip
    inx
    iny
    cpx TEMPLEN         ; has window reached last position?
    bne .mergeLoop      ; no, process next element
    ; x is at last nonzero position, therefore there is no more element to merge with

.doCopy
    +compressBuffer BUFFERTEMP, BUFFERIN
.done
    rts


!macro reverse .buffer {
    lda .buffer
    ldy .buffer+3
    sta .buffer+3
    sty .buffer
    lda .buffer+1
    ldy .buffer+2
    sta .buffer+2
    sty .buffer+1    
}


;--------------------------------------------------
; shiftRowRight implements a right shift of a row.
; Input and output in BUFFERIN 
; 
; INPUT:  None
; OUTPUT: None
; --------------------------------------------------
shiftRowRight
    +reverse BUFFERIN
    jsr shiftRowLeft
    +reverse BUFFERIN

    rts

ROWCOUNT !byte $00
COLCOUNT !byte $00
;--------------------------------------------------
; shiftPlayingField implements shifting the playing field. If .slow is equal to ROWCOUNT then
; the shift is horizontal. If .slow is set to COLCOUNT a vertical shift is performed. The parameter
; shiftCall then determines whether the shift is left/right or up/down. 
; 
; INPUT:  None
; OUTPUT: None
; --------------------------------------------------
!macro shiftPlayingField .slow, .fast, .shiftCall {
    lda #0
    sta .slow                    ; .slow is the slow counter
    sta .fast                    ; .fast is the fast counter

.count1CopyLoop
    ; Copy data into BUFFERIN
    lda ROWCOUNT
    ldx COLCOUNT
    jsr calcPlayFieldOffset           ; returns playing field offset in y
    lda PLAYINGFIELD, y
    ldx .fast
    sta BUFFERIN, X
    inc .fast
    lda .fast
    cmp #04
    bne .count1CopyLoop

    ; perform shift
    jsr .shiftCall

    ; reset fast counter
    lda #00
    sta .fast

    ; copy data back
.count1CopyBack
    lda ROWCOUNT
    ldx COLCOUNT
    jsr calcPlayFieldOffset           ; returns playing field offset in y
    ldx .fast
    lda BUFFERIN, x
    sta PLAYINGFIELD, Y
    inc .fast
    lda .fast
    cmp #04
    bne .count1CopyBack

    ; reset fast counter
    lda #00
    sta .fast

    ; increment and test slow counter
    inc .slow
    lda .slow
    cmp #04
    bne .count1CopyLoop
    rts
} 

shiftLeft
    +shiftPlayingField ROWCOUNT, COLCOUNT, shiftRowLeft

shiftRight
    +shiftPlayingField ROWCOUNT, COLCOUNT, shiftRowRight

shiftUp
    +shiftPlayingField COLCOUNT, ROWCOUNT, shiftRowLeft

shiftDown
    +shiftPlayingField COLCOUNT, ROWCOUNT, shiftRowRight